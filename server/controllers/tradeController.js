// ‚úÖ controllers/tradeController.js

import dotenv from 'dotenv';
dotenv.config();

// Utility imports

import { getGptRecommendation } from '../utils/openaiAssistant.js';
import { enrichTickerData } from '../utils/enrichTickerData.js';
import TradeRecommendation from '../models/TradeRecommendation.js';



// üîç Fetch aggregate (candlestick) data for a single ticker over the past 30 days
export const getAggregate = async (req, res) => {
  const { ticker } = req.params;
  const polygon = req.app.get('polygon');

  try {
    const endDate = new Date();
    const startDate = new Date(endDate);
    startDate.setDate(endDate.getDate() - 30); // Get 30-day window

    const data = await polygon.stocks.aggregates(
      ticker,
      1,
      "day",
      startDate.toISOString().split('T')[0],
      endDate.toISOString().split('T')[0]
    );

    res.json(data);
  } catch (error) {
    res.status(500).json({ error: `Failed to fetch data for ${ticker}` });
  }
};


// üîç Fetch aggregates for multiple tickers (useful for bulk analysis)
export const getMultiAggregates = async (req, res) => {
  const { tickers } = req.body;
  const polygon = req.app.get('polygon');

  if (!Array.isArray(tickers)) {
    return res.status(400).json({ error: 'Tickers must be an array.' });
  }

  try {
    const results = await Promise.all(
      tickers.map(ticker =>
        polygon.stocks.aggregates(ticker, 1, "day", "2024-05-01", "2024-05-07")
          .then(data => ({ ticker, data }))
          .catch(error => ({ ticker, error: error.message }))
      )
    );

    res.json(results);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch multiple aggregates' });
  }
};


// üßæ Get summary of last day‚Äôs data + latest trade recommendation for a given ticker
export const getSummary = async (req, res) => {
  const { ticker } = req.params;
  const polygon = req.app.get('polygon');

  console.log(`üîç getSummary (fallback) for: ${ticker}`);

  try {
    const endDate = new Date();
    const startDate = new Date(endDate);
    startDate.setDate(endDate.getDate() - 2); // last 2 days

    const agg = await polygon.stocks.aggregates(
      ticker,
      1,
      "day",
      startDate.toISOString().split('T')[0],
      endDate.toISOString().split('T')[0]
    );

    const lastDay = agg.results?.at(-1) || null;
    const trade = await TradeRecommendation.findOne({ tickers: ticker }).sort({ createdAt: -1 });

    res.json({
      trade,
      quote: lastDay ? {
        open: lastDay.o,
        high: lastDay.h,
        low: lastDay.l,
        close: lastDay.c,
        volume: lastDay.v,
        date: new Date(lastDay.t).toISOString()
      } : null
    });

  } catch (error) {
    console.error('üî• Fallback summary error:', error.message);
    res.status(500).json({ error: 'Summary fallback failed', message: error.message });
  }
};


export const validateTradeRequest = (req, res, next) => {
  let { tickers, ticker, watchlist, capital, riskTolerance } = req.body;

  // Normalize to tickers[]
  if (!tickers) {
    if (Array.isArray(watchlist)) {
      tickers = watchlist;
      req.body.tickers = tickers;
    } else if (ticker) {
      tickers = [ticker];
      req.body.tickers = tickers;
    }
  }

  if (!Array.isArray(tickers)) {
    return res.status(400).json({ error: 'Tickers must be an array or ticker must be provided' });
  }

  if (typeof capital !== 'number' || capital <= 0) {
    return res.status(400).json({ error: 'Invalid capital amount' });
  }

  if (!['low', 'medium', 'high'].includes(riskTolerance)) {
    return res.status(400).json({ error: 'Invalid risk tolerance value (must be low, medium, or high)' });
  }

  next();
};

// üß† Validates a single ticker and returns affordable options based on user capital
export const validateTicker = async (req, res) => {
  const { ticker, capital = 1000, riskTolerance = 'medium' } = req.body;
  const apiKey = process.env.POLYGON_API_KEY;

  console.log('\nüß† Validating Ticker & Checking Affordability...');
  console.log(`  üìà Ticker: ${ticker}`);
  console.log(`  üíµ Capital: $${capital}`);
  console.log(`  ‚öñÔ∏è Risk Tolerance: ${riskTolerance}`);
  console.log(`  üîë API Key Present: ${!!apiKey}`);

  if (!ticker) {
    return res.status(400).json({ valid: false, error: 'Ticker symbol is required.' });
  }

  try {
    // Step 1: Validate ticker
    const stockPrice = await getStockPrice(ticker);
    if (!stockPrice) {
      console.warn(`‚ùå Invalid ticker "${ticker}" ‚Äî No price data`);
      return res.status(404).json({
        valid: false,
        message: `Ticker "${ticker}" not found.`,
        stockPrice: null,
        contracts: [],
        closestITM: null
      });
    }

    // Step 2: Fetch CALL contracts user can afford
    const { contracts, cheapestUnaffordable, closestITM } = await getAffordableOptionContracts({
      ticker,
      capital,
      riskTolerance,
      apiKey,
      contractType: 'call'
    });

    // üí° Log the closest ITM contract
    if (closestITM) {
      console.log(`üéØ Closest ITM Contract Found: ${closestITM.ticker} | Strike: ${closestITM.strike_price}`);
    } else {
      console.log(`‚ö†Ô∏è No closest ITM found.`);
    }

    // Edge case: No affordable contracts
    if (!contracts.length && cheapestUnaffordable) {
      console.log(`üìâ No affordable contracts. Returning closest ITM fallback.`);
      return res.status(200).json({
        valid: true,
        message: `No CALL contracts under $${capital}. Closest ITM contract returned.`,
        stockPrice,
        contracts: [],
        closestITM
      });
    }

    // No contracts at all
    if (!contracts.length && !cheapestUnaffordable) {
      console.log(`‚ùå No viable contracts at all for ${ticker}.`);
      return res.status(200).json({
        valid: true,
        message: `No CALL contracts found for "${ticker}".`,
        stockPrice,
        contracts: [],
        closestITM: null
      });
    }

    // ‚úÖ Success: return all affordable CALL contracts
    console.log(`‚úÖ ${contracts.length} affordable contracts returned.`);
    return res.status(200).json({
      valid: true,
      message: `Found ${contracts.length} affordable CALL contracts.`,
      stockPrice,
      contracts,
      closestITM
    });

  } catch (err) {
    console.error('üî• Error during ticker validation:', err.message);
    return res.status(500).json({
      valid: false,
      error: 'Internal server error during ticker validation.',
      stockPrice: null,
      contracts: [],
      closestITM: null
    });
  }
};


/* ============================================================================
 üß† ANALYZE TRADE ‚Äî Main controller for processing trade recommendation
============================================================================ */
// ‚úÖ Controller: analyzeTrade ‚Äî Main endpoint to generate trade recommendations




// ‚úÖ File: controllers/tradeController.js

export const analyzeTrade = async (req, res) => {
  try {
    console.log("üöÄ [analyzeTrade] CONTROLLER TRIGGERED");
    console.log("üì• Request Body:", JSON.stringify(req.body, null, 2));

    const { capital, riskTolerance, watchlist } = req.body;

    // ========================
    // üõ°Ô∏è INPUT VALIDATION
    // ========================
    if (!capital || !riskTolerance || !Array.isArray(watchlist) || watchlist.length === 0) {
      const errorMsg = "‚ö†Ô∏è Missing required fields: capital, riskTolerance, or watchlist";
      console.warn(errorMsg);
      return res.status(400).json({ error: errorMsg });
    }

    const enrichedTickers = [];
    console.log(`üîÅ Processing ${watchlist.length} tickers in watchlist`);

    // ===========================================
    // üîÅ PROCESS EACH TICKER IN WATCHLIST
    // ===========================================
    for (const ticker of watchlist) {
      try {
        console.log(`\nüîç [TICKER PROCESSING] Starting analysis for: ${ticker}`);

        // ========================
        // üì¶ 1. DATA ENRICHMENT
        // ========================
        console.log(`üß† [PHASE 1] Enriching data for ${ticker}...`);
        const enrichedData = await enrichTickerData({
          ticker,
          capital,
          riskTolerance
        });

        // ========================
        // ‚úÖ 2. VALIDATION CHECKS
        // ========================
        console.log(`üõ°Ô∏è [PHASE 2] Validating enriched data for ${ticker}...`);

        // Check if enrichment failed
        if (!enrichedData) {
          console.warn(`‚õî SKIPPING: Enrichment failed for ${ticker}`);
          continue;
        }

        // Validate critical fields
        const missingFields = [];
        if (!enrichedData.stockPrice) missingFields.push('stockPrice');
        if (!enrichedData.contract) missingFields.push('contract');
        if (!enrichedData.indicators) missingFields.push('indicators');

        if (missingFields.length > 0) {
          console.warn(`‚ö†Ô∏è INCOMPLETE DATA: Missing ${missingFields.join(', ')} for ${ticker}`);
          console.dir(enrichedData, { depth: 2 });
          continue;
        }

        // Validate contract object structure
        const contract = enrichedData.contract;
        if (!contract || typeof contract.ask !== 'number' || typeof contract.strike_price !== 'number') {
          console.warn(`‚ö†Ô∏è INVALID CONTRACT: Missing required fields for ${ticker}`);
          console.log("üß™ Contract debug:", contract);
          continue;
        }

        // ========================
        // ü§ñ 3. GPT ANALYSIS
        // ========================
        console.log(`üß† [PHASE 3] Sending data to GPT for ${ticker}...`);

        // 1. Full contract validation and logging
        console.log("üîç [CONTRACT VALIDATION] Checking contract data integrity...");
        if (!contract || typeof contract !== 'object') {
          console.error(`‚ùå CRITICAL: Contract is ${typeof contract} for ${ticker}`);
        } else {
          console.log("‚úÖ Contract is a valid object");
          console.log("üìù Contract Details:", {
            ticker: contract.ticker,
            ask: contract.ask,
            strike: contract.strike_price,
            expiration: contract.expiration_date,
            delta: contract.delta,
            iv: contract.implied_volatility,
            oi: contract.open_interest
          });
        }

        // 2. Congressional data validation
        console.log("üèõÔ∏è [CONGRESS VALIDATION] Checking congressional data...");
        if (!enrichedData.congress) {
          console.warn("‚ö†Ô∏è Congressional data is empty");
        } else {
          console.log(`üìè Congress data length: ${enrichedData.congress.length} characters`);
          console.log("üìÑ Congress preview:", enrichedData.congress.substring(0, 100) + "...");
        }

        // 3. Full enriched data dump
        console.log("üì¶ [ENRICHED DATA DUMP] Full structure being sent to GPT:");
        console.log(JSON.stringify({
          ...enrichedData,
          // Protect sensitive data
          indicators: enrichedData.indicators ? "EXISTS" : "MISSING",
          sentiment: enrichedData.sentiment ? "EXISTS" : "MISSING",
          contract: enrichedData.contract ? {
            ticker: enrichedData.contract.ticker,
            ask: enrichedData.contract.ask,
            strike: enrichedData.contract.strike_price
          } : "UNDEFINED"
        }, null, 2));

        // 4. Send to GPT with additional validation
        try {
          console.log("üöÄ Sending to getGptRecommendation...");
          const gptResponse = await getGptRecommendation(enrichedData);

          // 5. GPT response validation
          if (!gptResponse?.tradeType) {
            console.error(`‚ùå INVALID GPT RESPONSE for ${ticker}:`, gptResponse);
            console.log("üß™ Response type:", typeof gptResponse);

            if (typeof gptResponse === 'string') {
              console.log("üìÑ String content:", gptResponse.substring(0, 200));
            }
            continue;
          }

          console.log(`üìù GPT RECOMMENDATION for ${ticker}: ${gptResponse.tradeType} (${gptResponse.confidence})`);

          // ... rest of your code ...
        } catch (gptError) {
          console.error(`üî• GPT PROCESSING ERROR for ${ticker}:`, gptError);
          console.error("Error details:", gptError.message);
          console.error("Stack trace:", gptError.stack);
        }
        // Validate GPT response
        if (!gptResponse?.tradeType || !gptResponse?.confidence) {
          console.error(`‚ùå INVALID GPT RESPONSE for ${ticker}:`, gptResponse);
          continue;
        }
        console.log(`üìù GPT RECOMMENDATION for ${ticker}: ${gptResponse.tradeType} (${gptResponse.confidence})`);

        // ========================
        // üíæ 4. SAVE TO DATABASE
        // ========================
        console.log(`üíæ [PHASE 4] Saving recommendation for ${ticker}...`);
        const newRec = new TradeRecommendation({
  tickers: [ticker],
  capital: enrichedData.capital,
  riskTolerance,
  recommendationDirection: gptResponse.tradeType.toLowerCase(),
  confidence: gptResponse.confidence.toLowerCase(),
  gptResponse: gptResponse.analysis,
  entryPrice: gptResponse.entryPrice,
  targetPrice: gptResponse.targetPrice,
  stopLoss: gptResponse.stopLoss,
  option: contract,
  expiryDate: contract?.expiration_date,
  sentimentSummary: enrichedData.sentiment,
  congressTrades: enrichedData.congress,
  indicators: enrichedData.indicators
});
        // Save the recommendation

        await newRec.save();
        console.log(`‚úÖ RECOMMENDATION SAVED for ${ticker}`);

        // ========================
        // üì¶ 5. ADD TO RESPONSE
        // ========================
        enrichedTickers.push({
          ticker,
          recommendation: gptResponse,
          option: contract
        });

      } catch (tickerError) {
        console.error(`‚ö†Ô∏è ERROR PROCESSING ${ticker}:`, tickerError.message);
      }
    }

    // ========================
    // üìÆ 6. FINAL RESPONSE
    // ========================
    console.log("\n‚úÖ PROCESSING COMPLETE");
    if (!enrichedTickers.length) {
      const errorMsg = "‚ö†Ô∏è No valid recommendations generated";
      console.warn(errorMsg);
      return res.status(500).json({ error: errorMsg });
    }

    console.log(`üéâ SUCCESS: Generated ${enrichedTickers.length} recommendations`);
    return res.status(200).json({
      message: "‚úÖ Trade recommendations created",
      recommendations: enrichedTickers
    });

  } catch (err) {
    console.error("üî• CRITICAL ERROR IN analyzeTrade:", err);
    return res.status(500).json({ error: "Server error during trade analysis." });
  }
};


// üìö Fetch all saved trade recommendations
export const getAllTrades = async (req, res) => {
  try {
    const trades = await TradeRecommendation.find().sort({ createdAt: -1 });
    res.json(trades);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch trade history' });
  }
};


// ‚úèÔ∏è Manually update trade outcome (win/loss/pending)
export const updateTradeOutcome = async (req, res) => {
  const { id } = req.params;
  const { outcome, userNotes } = req.body;

  if (!['win', 'loss', 'pending'].includes(outcome)) {
    return res.status(400).json({ error: 'Invalid outcome value' });
  }

  try {
    const updated = await TradeRecommendation.findByIdAndUpdate(
      id,
      { outcome, userNotes },
      { new: true }
    );

    if (!updated) return res.status(404).json({ error: 'Trade not found' });

    res.json(updated);
  } catch (error) {
    res.status(500).json({ error: 'Failed to update trade outcome' });
  }
};
