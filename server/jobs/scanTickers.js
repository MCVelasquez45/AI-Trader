// ‚úÖ File: server/controllers/scanner.js
import getStockPrice from '../utils/getStockPrice.js';
import calculateIndicators from '../utils/calculateIndicators.js';
import TradeRecommendation from '../models/TradeRecommendation.js';
import axios from 'axios';
import { getAffordableOptionContracts } from '../utils/getAffordableOptionContracts.js';

/**
 * Scans tickers for potential trades and saves the best option contract.
 */
const scanTickers = async ({ tickers, capital, riskTolerance }) => {
  const apiKey = process.env.POLYGON_API_KEY;

  for (const ticker of tickers) {
    console.log(`\nüì° Scanning ${ticker}...`);

    // ‚úÖ Step 1: Get stock price
    const price = await getStockPrice(ticker);
    if (!price) {
      console.warn(`‚ùå Skipping ${ticker}: Price unavailable`);
      continue;
    }

    console.log(`üí∞ ${ticker} current price: $${price}`);

    // ‚úÖ Step 2: Get historical candles
    let candles = [];
    try {
      const from = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
      const to = new Date().toISOString().split('T')[0];
      const url = `https://api.polygon.io/v2/aggs/ticker/${ticker}/range/1/day/${from}/${to}?adjusted=true&sort=asc&limit=60&apiKey=${apiKey}`;
      const response = await axios.get(url);

      candles = response.data.results.map(c => ({
        c: c.c,
        h: c.h,
        l: c.l,
        v: c.v,
        t: c.t
      }));
    } catch (err) {
      console.warn(`‚ùå Failed to fetch candles for ${ticker}: ${err.message}`);
    }

    // ‚úÖ Step 3: Indicators
    const { rsi, vwap, macd } = calculateIndicators(candles);

    console.log(`üìà RSI: ${rsi}, VWAP: ${vwap}, MACD Hist: ${macd?.histogram}`);

    // ‚úÖ Step 4: Find contracts
    try {
      const { contracts } = await getAffordableOptionContracts({
        ticker,
        capital,
        riskTolerance,
        rsi,
        vwap,
        macd,
        apiKey
      });

      if (!contracts?.length) {
        console.warn(`‚ö†Ô∏è No affordable contracts found for ${ticker}`);
        continue;
      }

      const best = contracts.sort((a, b) => (b.delta || 0) - (a.delta || 0))[0];
      const recommendationDirection = best.delta > 0.5 ? 'call' : 'put';
      const estimatedCost = (best.ask ?? best.bid ?? best.close ?? 0) * 100;
      const breakEvenPrice = best.strike_price + (estimatedCost / 100);
      const expectedROI = ((breakEvenPrice - price) / estimatedCost) * 100;

      const recommendation = new TradeRecommendation({
        tickers: [ticker],
        capital,
        riskTolerance,
        entryPrice: price,
        estimatedCost,
        breakEvenPrice,
        expectedROI,
        expiryDate: best.expiration_date,
        targetPrice: breakEvenPrice + 5, // rough placeholder logic
        stopLoss: price - 5, // rough placeholder logic
        option: {
          ticker: best.ticker,
          strike_price: best.strike_price,
          expiration_date: best.expiration_date,
          contract_type: best.contract_type,
          ask: best.ask,
          bid: best.bid,
          delta: best.delta,
          gamma: best.gamma,
          theta: best.theta,
          vega: best.vega,
          implied_volatility: best.implied_volatility,
          open_interest: best.open_interest
        },
        gptPrompt: 'AUTO-SCANNER (No GPT used)',
        gptResponse: 'This trade was auto-generated by the scanner without GPT reasoning.',
        recommendationDirection,
        confidence: 'medium',
        indicators: { rsi, vwap, macd },
        sentimentSummary: 'Auto-scan pending full analysis.',
        outcome: 'pending'
      });

      await recommendation.save();

      console.log(`üíæ Saved trade for ${ticker}: ${best.ticker} (${recommendationDirection.toUpperCase()})`);

    } catch (err) {
      console.error(`‚ùå Error processing ${ticker}: ${err.message}`);
    }
  }
};

export default scanTickers;
